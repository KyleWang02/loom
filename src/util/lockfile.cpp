#include <loom/lockfile.hpp>
#include <tomlplusplus/toml.hpp>

#include <algorithm>
#include <fstream>
#include <sstream>
#include <unordered_set>

namespace loom {

// ---------------------------------------------------------------------------
// LockFile::load
// ---------------------------------------------------------------------------

Result<LockFile> LockFile::load(const std::string& path) {
    std::ifstream in(path);
    if (!in) {
        return LoomError{LoomError::NotFound,
            "cannot open lockfile: " + path};
    }

    std::stringstream buf;
    buf << in.rdbuf();

    toml::table tbl;
    try {
        tbl = toml::parse(buf.str());
    } catch (const toml::parse_error& e) {
        return LoomError{LoomError::Parse,
            std::string("lockfile parse error: ") + e.what()};
    }

    LockFile lf;

    // Top-level fields
    if (auto v = tbl["loom_version"].value<std::string>()) {
        lf.loom_version = *v;
    }

    // [root] section
    if (auto root = tbl["root"].as_table()) {
        if (auto v = root->get("name")) {
            if (auto s = v->value<std::string>()) lf.root_name = *s;
        }
        if (auto v = root->get("version")) {
            if (auto s = v->value<std::string>()) lf.root_version = *s;
        }
    }

    // [[packages]] array
    if (auto pkgs = tbl["packages"].as_array()) {
        for (const auto& elem : *pkgs) {
            const auto* pkg_tbl = elem.as_table();
            if (!pkg_tbl) continue;

            LockedPackage lp;
            if (auto v = pkg_tbl->get("name")) {
                if (auto s = v->value<std::string>()) lp.name = *s;
            }
            if (auto v = pkg_tbl->get("version")) {
                if (auto s = v->value<std::string>()) lp.version = *s;
            }
            if (auto v = pkg_tbl->get("source")) {
                if (auto s = v->value<std::string>()) lp.source = *s;
            }
            if (auto v = pkg_tbl->get("commit")) {
                if (auto s = v->value<std::string>()) lp.commit = *s;
            }
            if (auto v = pkg_tbl->get("ref")) {
                if (auto s = v->value<std::string>()) lp.ref = *s;
            }
            if (auto v = pkg_tbl->get("checksum")) {
                if (auto s = v->value<std::string>()) lp.checksum = *s;
            }

            if (auto deps = pkg_tbl->get("dependencies")) {
                if (auto arr = deps->as_array()) {
                    for (const auto& d : *arr) {
                        if (auto s = d.value<std::string>()) {
                            lp.dependencies.push_back(*s);
                        }
                    }
                }
            }

            lf.packages.push_back(std::move(lp));
        }
    }

    return Result<LockFile>::ok(std::move(lf));
}

// ---------------------------------------------------------------------------
// LockFile::save
// ---------------------------------------------------------------------------

Status LockFile::save(const std::string& path) const {
    std::ofstream out(path);
    if (!out) {
        return LoomError{LoomError::IO,
            "cannot write lockfile: " + path};
    }

    out << "# This file is auto-generated by Loom. Do not edit.\n";
    out << "loom_version = " << '"' << loom_version << '"' << "\n\n";

    out << "[root]\n";
    out << "name = " << '"' << root_name << '"' << "\n";
    out << "version = " << '"' << root_version << '"' << "\n";

    // Sort packages by name for deterministic output
    auto sorted = packages;
    std::sort(sorted.begin(), sorted.end(),
              [](const LockedPackage& a, const LockedPackage& b) {
                  return a.name < b.name;
              });

    for (const auto& pkg : sorted) {
        out << "\n[[packages]]\n";
        out << "name = " << '"' << pkg.name << '"' << "\n";
        out << "version = " << '"' << pkg.version << '"' << "\n";
        out << "source = " << '"' << pkg.source << '"' << "\n";
        if (!pkg.commit.empty()) {
            out << "commit = " << '"' << pkg.commit << '"' << "\n";
        }
        if (!pkg.ref.empty()) {
            out << "ref = " << '"' << pkg.ref << '"' << "\n";
        }
        if (!pkg.checksum.empty()) {
            out << "checksum = " << '"' << pkg.checksum << '"' << "\n";
        }
        if (!pkg.dependencies.empty()) {
            out << "dependencies = [";
            for (size_t i = 0; i < pkg.dependencies.size(); ++i) {
                if (i > 0) out << ", ";
                out << '"' << pkg.dependencies[i] << '"';
            }
            out << "]\n";
        }
    }

    return ok_status();
}

// ---------------------------------------------------------------------------
// LockFile::find
// ---------------------------------------------------------------------------

const LockedPackage* LockFile::find(const std::string& name) const {
    for (const auto& pkg : packages) {
        if (pkg.name == name) return &pkg;
    }
    return nullptr;
}

// ---------------------------------------------------------------------------
// LockFile::is_stale
// ---------------------------------------------------------------------------

bool LockFile::is_stale(const std::vector<Dependency>& manifest_deps) const {
    // Build set of locked package names
    std::unordered_set<std::string> locked_names;
    for (const auto& pkg : packages) {
        locked_names.insert(pkg.name);
    }

    // Check each manifest dep is in the lockfile
    for (const auto& dep : manifest_deps) {
        if (locked_names.find(dep.name) == locked_names.end()) {
            return true;  // New dependency not in lock
        }
    }

    // Build set of manifest dep names
    std::unordered_set<std::string> manifest_names;
    for (const auto& dep : manifest_deps) {
        manifest_names.insert(dep.name);
    }

    // Check for removed deps (in lock but not in manifest)
    for (const auto& pkg : packages) {
        if (manifest_names.find(pkg.name) == manifest_names.end()) {
            return true;  // Removed dependency
        }
    }

    // Check source changes
    for (const auto& dep : manifest_deps) {
        const auto* locked = find(dep.name);
        if (!locked) return true;

        if (dep.git) {
            std::string expected_source = "git+" + dep.git->url;
            if (locked->source != expected_source) return true;
        } else if (dep.path) {
            std::string expected_source = "path+" + dep.path->path;
            if (locked->source != expected_source) return true;
        }
    }

    return false;
}

} // namespace loom
